# Лабораторная работа: Настройка непрерывной интеграции с GitHub Actions

## Цель работы
В рамках данной работы студенты научатся настраивать непрерывную интеграцию с помощью Github Actions.

## Задание
Создать Web приложение, написать тесты для него и настроить непрерывную интеграцию с помощью Github Actions на базе контейнеров.

## Пошаговое выполнение работы

### 1. Создание базовой структуры проекта

Создан репозиторий `containers08` со следующей структурой файлов:
```
containers08/
├── .github/workflows/main.yml
├── site/
│   ├── modules/database.php
│   ├── modules/page.php
│   ├── templates/index.tpl
│   ├── styles/style.css
│   ├── config.php
│   └── index.php
├── sql/schema.sql
├── tests/
│   ├── testframework.php
│   └── tests.php
├── Dockerfile
└── README.md
```

### 2. Разработка Web-приложения

#### 2.1 Класс Database (`site/modules/database.php`)

При разработке класса Database я использую PDO вместо стандартных функций работы с SQLite по нескольким причинам:

- PDO предоставляет более безопасный способ выполнения запросов (подготовленные выражения)

- Более современный и объектно-ориентированный подход

- Лучшая обработка ошибок через механизм исключений

Реализованы следующие методы согласно заданию:
```php
__construct($path) // Для инициализации подключения
Execute($sql) // Выполнение любого SQL без возврата результата
Fetch($sql) // Выполнение запроса с возвратом данных
Create($table, $data) // Создание записей
Read($table, $id) // Чтение записи по ID
Update($table, $id, $data) // Обновление записи
Delete($table, $id) // Удаление записи
Count($table) // Подсчет числа записей
```

Пример подготовленных запросов для защиты от sql иньекции, в методе Create():

```php
$columns = implode(', ', array_keys($data));
$placeholders = implode(', ', array_fill(0, count($data), '?'));
$sql = "INSERT INTO {$table} ({$columns}) VALUES ({$placeholders})";
$stmt = $this->pdo->prepare($sql);
$stmt->execute(array_values($data));
```

Такой подход делает код более безопасным, так как значения передаются отдельно от SQL-запроса.

#### 2.2 Класс Page (`site/modules/page.php`)

Для класса Page я реализовал простую шаблонизацию с заменой плейсхолдеров на реальные данные. Хотя существуют более продвинутые шаблонизаторы (Twig, Blade):

```php
public function Render($data) {
    $content = file_get_contents($this->template);
    
    if (!empty($data) && is_array($data)) {
        foreach ($data as $key => $value) {
            $content = str_replace('{{' . $key . '}}', htmlspecialchars($value), $content);
        }
    }
    
    return $content;
}
```

Так же добавляю вызов `htmlspecialchars()` для защиты от XSS-атак.

#### 2.3 Шаблон страницы и стили

Создаю следующую структуру страницы в index.tpl:

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{{title}}</title>
    <link rel="stylesheet" href="styles/style.css">
</head>
<body>
    <div class="container">
        <header>...</header>
        <main>...</main>
        <footer>...</footer>
    </div>
</body>
</html>
```

#### 2.4 Главный файл приложения

В главном файле `index.php` реализованна следующая логика:
- Подключение необходимых компонентов
- Получение идентификатора страницы из GET-параметра
- Валидация входных данных (преобразование в целое число)
- Обработка случая, когда страница не найдена

### 3. SQL-схема базы данных

Создается структура базы данных с одной таблицей `page` и добавляются тестовые записи для проверки функциональности приложения.

### 4. Разработка тестов

Каждый тест проверяет конкретный аспект функциональности. Каждый тест имеет три основные фазы:
1. Подготовка (arrange) - подготовка тестовых данных
2. Действие (act) - вызов тестируемого метода
3. Проверка (assert) - проверка результатов

Например, в тесте `testDbUpdate()` я сначала создаю запись, затем обновляю её и, наконец, проверяю, что обновление произошло корректно.

Так же обычно добавляют тщательную обработку исключений, чтобы тесты могли корректно обработать ошибки и предоставить полезную информацию о проблеме.

### 5. Dockerfile

Примечание описание работы Dockerfile, я сделал при помощи комментариев.

```dockerfile
FROM php:8.4-fpm as base

# Установка SQLite и расширений
RUN apt-get update && \
    apt-get install -y sqlite3 libsqlite3-dev && \
    docker-php-ext-install pdo_sqlite

# Том для базы данных
VOLUME ["/var/www/db"]

# Копирование и инициализация базы данных
COPY sql/schema.sql /var/www/db/schema.sql
RUN echo "prepare database" && \
    cat /var/www/db/schema.sql | sqlite3 /var/www/db/db.sqlite && \
    chmod 777 /var/www/db/db.sqlite && \
    rm -rf /var/www/db/schema.sql

# Копирование файлов сайта
COPY site /var/www/html
```

Для базы данных создается отдельный том, что позволяет данным сохраняться даже после пересоздания контейнера.

### 6. Настройка GitHub Actions

В файле `.github/workflows/main.yml` я настроил процесс непрерывной интеграции:

```yaml
name: CI

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  build:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
      # Остальные шаги...
```

Я добавил запуск CI как при push в основную ветку, так и при создании pull request, что позволяет проверять код на ошибки до его попадания в основную ветку.

В процессе CI выполняются следующие шаги:
1. Сборка Docker образа
2. Создание контейнера с использованием именованного тома
3. Копирование тестов в контейнер
4. Запуск тестов внутри контейнера


## Ответы на вопросы

### Что такое непрерывная интеграция?
Непрерывная интеграция (CI, Continuous Integration) — это практика разработки программного обеспечения, при которой члены команды регулярно объединяют свои изменения кода в центральном репозитории, после чего автоматически выполняются сборка и тесты. Основная цель CI — как можно раньше обнаруживать и исправлять ошибки, что делает процесс разработки более быстрым и эффективным.

### Для чего нужны юнит-тесты? Как часто их нужно запускать?
Юнит-тесты (модульные тесты) нужны для проверки корректной работы отдельных компонентов (модулей) программы в изоляции от других компонентов. Они позволяют:
- Обнаруживать ошибки на ранних стадиях разработки
- Упрощать внесение изменений в код (благодаря уверенности, что изменения не нарушат существующую функциональность)
- Улучшать дизайн кода, так как хорошо тестируемый код обычно имеет лучшую архитектуру
- Служить документацией по использованию компонентов

Юнит-тесты следует запускать:
- При каждом изменении кода (перед фиксацией в репозитории)
- При каждом слиянии изменений в основную ветку (например, через pull request)
- В рамках процесса непрерывной интеграции (автоматически при каждом push)

### Что нужно изменить в файле `.github/workflows/main.yml` для того, чтобы тесты запускались при каждом создании запроса на слияние (Pull Request)?
Для запуска тестов при создании Pull Request необходимо добавить следующую секцию в блок `on:`:

```yaml
on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
```

Это уже было добавлено в файл `main.yml`.

### Что нужно добавить в файл `.github/workflows/main.yml` для того, чтобы удалять созданные образы после выполнения тестов?
Для удаления созданных Docker-образов после выполнения тестов нужно добавить дополнительный шаг в конце job:

```yaml
- name: Clean up Docker resources
  run: |
    docker rmi containers08 --force
    docker volume rm database || true
```

Эта команда удаляет образ с тегом `containers08` и также пытается удалить созданный при тестировании том `database`.

## Выводы
В ходе выполнения лабораторной работы были созданы PHP-приложение, тесты для него и настроен процесс непрерывной интеграции с использованием GitHub Actions и Docker. 

Основные результаты:
1. Создано веб-приложение с использованием PHP и SQLite
2. Разработаны тесты для проверки функциональности приложения